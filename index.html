<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>English Racing Numbers - CE1</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; color: white; }
        .menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: all; }
        .btn { pointer-events: all; background: #ef4444; color: white; padding: 15px 30px; border-radius: 50px; font-size: 1.5rem; margin: 10px; cursor: pointer; transition: all 0.2s; border: 4px solid #ffffff; min-width: 250px; text-align: center; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .btn:hover { background: #dc2626; transform: scale(1.05); }
        .progress-box { background: rgba(0,0,0,0.6); padding: 10px 25px; border-radius: 30px; font-size: 1.5rem; border: 2px solid white; pointer-events: none; }
        #message { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 5rem; font-weight: bold; text-shadow: 4px 4px 0px #000; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 50; text-align: center; }
        
        #end-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 200; color: white; pointer-events: all; }
        .star { font-size: 80px; color: #ffd700; text-shadow: 0 0 20px gold; display: inline-block; animation: pop 0.5s ease-out forwards; opacity: 0; }
        .trophy { font-size: 120px; animation: bounce 1s infinite alternate; }
        @keyframes pop { from { transform: scale(0); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-20px); } }
       #confetti-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 300; }
       
       /* Camera Button Style */
       .cam-btn { background: #3b82f6; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.8rem; border: 3px solid white; cursor: pointer; pointer-events: all; transition: transform 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
       .cam-btn:hover { transform: scale(1.1); background: #2563eb; }
    </style>
</head>
<body>

    <canvas id="confetti-canvas"></canvas>

    <div id="menu" class="menu-overlay">
        <h1 class="text-6xl font-black mb-4 text-yellow-400 italic">RACING NUMBERS</h1>
        <p class="mb-10 text-2xl text-white font-bold">Listen and Drive!</p>
        <button class="btn" onclick="startGame(6)">LEVEL 1 (1 - 6)</button>
        <button class="btn" onclick="startGame(10)">LEVEL 2 (1 - 10)</button>
        <button class="btn" onclick="startGame(20)">LEVEL 3 (1 - 20)</button>
    </div>

    <div id="end-screen">
        <div id="end-visuals" class="mb-4"></div>
        <h2 id="end-title" class="text-5xl font-black mb-4 italic">WELL DONE!</h2>
        <p id="end-score" class="text-2xl mb-8 font-bold"></p>
        <button class="btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <div id="ui-layer">
        <div class="flex justify-between items-start w-full">
            <div class="progress-box" id="progress">QUESTION: 0 / 10</div>
            <div class="flex gap-2">
                <button class="cam-btn" onclick="switchCamera()" title="Changer de vue">üì∑</button>
                <button class="btn !text-sm !p-2 !min-w-0 !m-0 !h-[60px] !flex !items-center" style="pointer-events: all;" onclick="location.reload()">MENU</button>
            </div>
        </div>
        <div id="instruction" class="text-center text-4xl font-black italic bg-blue-600/80 p-6 rounded-full self-center border-4 border-white">
            READY?
        </div>
    </div>

    <div id="message">GREAT!</div>

    <script>
        let scene, camera, renderer, car, clock;
        let lanes = [-5, 0, 5];
        let currentLane = 1;
        let targetLaneX = 0;
        let questionCount = 0;
        let correctAnswers = 0;
        let maxQuestions = 10;
        let maxNumber = 6;
        let currentTarget = null;
        let objects = [];
        let clouds = [];
        let scenery = []; 
        let isPlaying = false;
        let gameSpeed = 0.6;
        let roadTiles = [];
        let smokeParticles = [];
        
        // Camera modes: 0 = Default, 1 = Hood, 2 = Aerial
        let cameraMode = 0;
        
        const apiKey = "";

        let confettis = [];
        const confCanvas = document.getElementById('confetti-canvas');
        const confCtx = confCanvas.getContext('2d');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x40a0ff); 
            scene.fog = new THREE.Fog(0x40a0ff, 30, 150);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.1);
            sunLight.position.set(20, 40, 20);
            sunLight.castShadow = true;
            
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -30;
            sunLight.shadow.camera.right = 30;
            sunLight.shadow.camera.top = 30;
            sunLight.shadow.camera.bottom = -30;
            
            scene.add(sunLight);

            createRoad();
            createCar();

            for(let i=0; i<15; i++) {
                createCloud(Math.random()*120 - 60, 15 + Math.random()*10, -Math.random()*150);
            }
            
            for(let i=0; i<25; i++) {
                createTree(Math.random() > 0.5 ? 12 + Math.random()*5 : -12 - Math.random()*5, -i * 12);
            }

            clock = new THREE.Clock();
            resizeConfetti();
            animate();

            window.addEventListener('touchstart', (e) => {
                if(!isPlaying) return;
                if(e.target.tagName === 'BUTTON') return;
                
                const touchX = e.touches[0].clientX;
                const screenWidth = window.innerWidth;
                
                if (touchX < screenWidth / 2) {
                    if (currentLane > 0) currentLane--;
                } else {
                    if (currentLane < 2) currentLane++;
                }
                targetLaneX = lanes[currentLane];
            }, { passive: false });
        }

        function switchCamera() {
            cameraMode = (cameraMode + 1) % 3;
            const modes = ["VUE ARRI√àRE", "VUE CAPOT", "VUE A√âRIENNE"];
            showFeedback(modes[cameraMode], "#ffffff");
        }

        function updateCameraPosition() {
            if (!car) return;

            if (cameraMode === 0) {
                const targetPos = new THREE.Vector3(0, 6, 12);
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(0, 2, -5);
            } else if (cameraMode === 1) {
                const targetPos = new THREE.Vector3(car.position.x, 1.8, 0.5);
                camera.position.lerp(targetPos, 0.2);
                camera.lookAt(car.position.x, 1.5, -20);
            } else if (cameraMode === 2) {
                const targetPos = new THREE.Vector3(0, 25, 25);
                camera.position.lerp(targetPos, 0.1);
                camera.lookAt(0, 0, -60); 
            }
        }

        function resizeConfetti() {
            confCanvas.width = window.innerWidth;
            confCanvas.height = window.innerHeight;
        }

        function createRoad() {
            for(let i=0; i<25; i++) {
                const segment = new THREE.Group();
                const roadGeo = new THREE.BoxGeometry(16, 0.2, 10);
                const roadMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const road = new THREE.Mesh(roadGeo, roadMat);
                road.receiveShadow = true;
                segment.add(road);

                const lineGeo = new THREE.BoxGeometry(0.3, 0.25, 4);
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                [-2.5, 2.5].forEach(lx => {
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.receiveShadow = true;
                    line.position.set(lx, 0.05, 0);
                    segment.add(line);
                });

                const grassGeo = new THREE.BoxGeometry(100, 0.15, 10);
                const grassMat = new THREE.MeshPhongMaterial({ color: 0x2d8a2d });
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.receiveShadow = true;
                grass.position.y = -0.1;
                segment.add(grass);

                segment.position.z = -i * 10;
                scene.add(segment);
                roadTiles.push(segment);
            }
        }

        function createCar() {
            const carGroup = new THREE.Group();
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            
            const cylinderGeo = new THREE.CylinderGeometry(0.7, 0.7, 2, 16);
            const mainBody = new THREE.Mesh(cylinderGeo, bodyMat);
            mainBody.rotation.x = Math.PI / 2;
            mainBody.castShadow = true;
            carGroup.add(mainBody);

            const capGeo = new THREE.SphereGeometry(0.7, 16, 16);
            const frontCap = new THREE.Mesh(capGeo, bodyMat);
            frontCap.position.z = -1;
            frontCap.castShadow = true;
            carGroup.add(frontCap);

            const backCap = new THREE.Mesh(capGeo, bodyMat);
            backCap.position.z = 1;
            backCap.castShadow = true;
            carGroup.add(backCap);

            const cockGeo = new THREE.SphereGeometry(0.5, 16, 16);
            const cockMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const cock = new THREE.Mesh(cockGeo, cockMat);
            cock.position.set(0, 0.5, 0);
            cock.scale.set(1, 0.6, 1.5);
            cock.castShadow = true;
            carGroup.add(cock);

            const wingGeo = new THREE.BoxGeometry(2.2, 0.2, 0.8);
            const wing = new THREE.Mesh(wingGeo, bodyMat);
            wing.position.set(0, 0.8, 1.3);
            wing.castShadow = true;
            carGroup.add(wing);

            const wheelGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.6, 24);
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const wheelsPos = [[1.1, -0.2, 1.2], [-1.1, -0.2, 1.2], [1, -0.2, -1.2], [-1, -0.2, -1.2]];
            wheelsPos.forEach(pos => {
                const w = new THREE.Mesh(wheelGeo, wheelMat);
                w.rotation.z = Math.PI/2;
                w.position.set(...pos);
                w.castShadow = true;
                carGroup.add(w);
            });

            car = carGroup;
            car.position.y = 0.8;
            scene.add(car);
        }

        function createSmokeParticle(x, z) {
            const geo = new THREE.SphereGeometry(Math.random() * 0.3 + 0.1, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.6 });
            const p = new THREE.Mesh(geo, mat);
            p.position.set(x + (Math.random() - 0.5), 0.2, z + (Math.random() - 0.5));
            scene.add(p);
            smokeParticles.push({
                mesh: p,
                life: 1.0,
                vx: (Math.random() - 0.5) * 0.05,
                vy: 0.02 + Math.random() * 0.03,
                vz: 0.05 + Math.random() * 0.05
            });
        }

        function updateSmoke() {
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const p = smokeParticles[i];
                p.life -= 0.02;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    smokeParticles.splice(i, 1);
                    continue;
                }
                p.mesh.position.x += p.vx;
                p.mesh.position.y += p.vy;
                p.mesh.position.z += p.vz;
                p.mesh.scale.multiplyScalar(1.02);
                p.mesh.material.opacity = p.life * 0.6;
            }
        }

        function createCloud(x, y, z) {
            const cloudGroup = new THREE.Group();
            const mat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
            const spheresCount = 4 + Math.floor(Math.random() * 3);
            for(let i=0; i<spheresCount; i++) {
                const size = 2 + Math.random() * 3;
                const geo = new THREE.SphereGeometry(size, 16, 16);
                const sphere = new THREE.Mesh(geo, mat);
                sphere.position.set(i * 2, Math.random() * 2, Math.random() * 2);
                cloudGroup.add(sphere);
            }
            cloudGroup.position.set(x, y, z);
            scene.add(cloudGroup);
            clouds.push(cloudGroup);
        }

        function createTree(x, z) {
            const treeGroup = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 3, 12);
            const trunkMat = new THREE.MeshPhongMaterial({ color: 0x5d4037 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leafMat = new THREE.MeshPhongMaterial({ color: 0x2e7d32 });
            const spheresCount = 3 + Math.floor(Math.random() * 2);
            for(let i=0; i<spheresCount; i++) {
                const size = 1.5 + Math.random() * 1.5;
                const geo = new THREE.SphereGeometry(size, 16, 16);
                const leaf = new THREE.Mesh(geo, leafMat);
                leaf.position.set(Math.random() - 0.5, 3 + Math.random() * 2, Math.random() - 0.5);
                leaf.castShadow = true;
                treeGroup.add(leaf);
            }
            treeGroup.position.set(x, 0, z);
            scene.add(treeGroup);
            scenery.push(treeGroup);
        }

        async function nextTurn() {
            if(!isPlaying) return;
            if(questionCount >= maxQuestions) {
                endGame();
                return;
            }
            questionCount++;
            document.getElementById('progress').innerText = `QUESTION: ${questionCount} / 10`;
            const availableNumbers = Array.from({length: maxNumber}, (_, i) => i + 1);
            currentTarget = availableNumbers[Math.floor(Math.random() * availableNumbers.length)];
            document.getElementById('instruction').innerText = `LISTEN...`;
            await speak(`Go to number ${currentTarget}`);
            setTimeout(() => {
                spawnNumbers();
                document.getElementById('instruction').innerText = `TARGET: ?`;
            }, 1000);
        }

        function spawnNumbers() {
            const correctLane = Math.floor(Math.random() * 3);
            const group = new THREE.Group();
            for(let i=0; i<3; i++) {
                const boxGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
                const boxMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.x = lanes[i];
                box.position.y = 2.5; 
                box.castShadow = true;
                
                let val = (i === correctLane) ? currentTarget : Math.ceil(Math.random() * maxNumber);
                if(i !== correctLane && val === currentTarget) val = (val % maxNumber) + 1;
                
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,256,256);
                ctx.fillStyle = '#1e3a8a'; ctx.font = 'bold 150px Arial'; ctx.textAlign = 'center';
                ctx.fillText(val, 128, 180);
                const texture = new THREE.CanvasTexture(canvas);
                box.material = new THREE.MeshPhongMaterial({ map: texture });
                box.userData = { value: val };
                group.add(box);
            }
            group.position.z = -150; 
            scene.add(group);
            objects.push(group);
        }

        async function speak(text) {
            return new Promise(async (resolve) => {
                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: `Say with energy: ${text}` }] }],
                            generationConfig: {
                                responseModalities: ["AUDIO"],
                                speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Puck" } } }
                            }
                        })
                    });
                    const data = await response.json();
                    const audioBase64 = data.candidates[0].content.parts[0].inlineData.data;
                    playPCM(audioBase64, resolve);
                } catch (e) {
                    const msg = new SpeechSynthesisUtterance(text);
                    msg.lang = 'en-US';
                    msg.onend = () => resolve();
                    window.speechSynthesis.speak(msg);
                }
            });
        }

        function playPCM(base64, callback) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            const wavHeader = new ArrayBuffer(44);
            const view = new DataView(wavHeader);
            const sampleRate = 24000;
            view.setUint32(0, 0x52494646, false); view.setUint32(4, 36 + binary.length, true); view.setUint32(8, 0x57415645, false);
            view.setUint32(12, 0x666d7420, false); view.setUint32(16, 16, true); view.setUint16(20, 1, true);
            view.setUint16(22, 1, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true); view.setUint16(34, 16, true); view.setUint32(36, 0x64617461, false); view.setUint32(40, binary.length, true);
            const audio = new Audio(URL.createObjectURL(new Blob([wavHeader, bytes], { type: 'audio/wav' })));
            audio.onended = () => callback();
            audio.play();
        }

        function showFeedback(text, color) {
            const el = document.getElementById('message');
            el.innerText = text;
            el.style.color = color;
            el.style.opacity = '1';
            setTimeout(() => el.style.opacity = '0', 800);
        }

        function endGame() {
            isPlaying = false;
            const endScreen = document.getElementById('end-screen');
            const visual = document.getElementById('end-visuals');
            const scoreText = document.getElementById('end-score');
            const title = document.getElementById('end-title');
            
            endScreen.style.display = 'flex';
            scoreText.innerText = `YOU GOT ${correctAnswers} / 10`;
            visual.innerHTML = '';

            if (correctAnswers === 10) {
                title.innerText = "GRAND PRIX WINNER!";
                visual.innerHTML = '<div class="trophy">üèÜ</div>';
                startFireworks();
            } else {
                title.innerText = "WELL DONE!";
                let stars = (correctAnswers >= 9) ? 3 : (correctAnswers >= 6) ? 2 : 1;
                for(let i=0; i<stars; i++) {
                    const s = document.createElement('span');
                    s.className = 'star';
                    s.innerText = '‚≠ê';
                    s.style.animationDelay = `${i * 0.3}s`;
                    visual.appendChild(s);
                }
            }
        }

        function startFireworks() {
            for(let i=0; i<100; i++) {
                confettis.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight - window.innerHeight,
                    r: 4 + Math.random() * 6,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    vy: 2 + Math.random() * 4,
                    vx: Math.random() * 2 - 1,
                    rotation: Math.random() * Math.PI
                });
            }
        }

        function drawConfetti() {
            confCtx.clearRect(0,0,confCanvas.width, confCanvas.height);
            confettis.forEach((c, i) => {
                c.y += c.vy;
                c.x += c.vx;
                c.rotation += 0.1;
                if(c.y > confCanvas.height) c.y = -10;
                
                confCtx.save();
                confCtx.translate(c.x, c.y);
                confCtx.rotate(c.rotation);
                confCtx.fillStyle = c.color;
                confCtx.fillRect(-c.r/2, -c.r/2, c.r, c.r);
                confCtx.restore();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            drawConfetti();
            updateCameraPosition();
            updateSmoke();
            
            if(isPlaying) {
                roadTiles.forEach(tile => {
                    tile.position.z += gameSpeed;
                    if(tile.position.z > 20) tile.position.z -= 250;
                });
                clouds.forEach(cloud => {
                    cloud.position.z += gameSpeed * 0.3;
                    if(cloud.position.z > 30) cloud.position.z = -150;
                });
                scenery.forEach(tree => {
                    tree.position.z += gameSpeed;
                    if(tree.position.z > 20) {
                        tree.position.z = -200;
                        tree.position.x = Math.random() > 0.5 ? 12 + Math.random()*5 : -12 - Math.random()*5;
                    }
                });

                // D√©tection du d√©placement lat√©ral pour la fum√©e
                const diffX = Math.abs(car.position.x - targetLaneX);
                if (diffX > 0.1) {
                    // Si la voiture bouge, on cr√©e de la fum√©e derri√®re les roues
                    createSmokeParticle(car.position.x + 1, car.position.z + 1.2);
                    createSmokeParticle(car.position.x - 1, car.position.z + 1.2);
                }

                car.position.x = THREE.MathUtils.lerp(car.position.x, targetLaneX, 0.12);
                car.rotation.z = -(car.position.x - targetLaneX) * 0.15;
                car.rotation.y = (car.position.x - targetLaneX) * 0.08;

                objects.forEach((group, index) => {
                    group.position.z += gameSpeed;
                    if(group.position.z > -3 && group.position.z < 0) {
                        const hitObject = group.children[currentLane];
                        if(hitObject.userData.value === currentTarget) {
                            correctAnswers++;
                            showFeedback("EXCELLENT!", "#facc15");
                        } else {
                            showFeedback("OOPS!", "#ef4444");
                        }
                        scene.remove(group);
                        objects.splice(index, 1);
                        setTimeout(nextTurn, 1500);
                    } else if (group.position.z > 10) {
                        scene.remove(group);
                        objects.splice(index, 1);
                        nextTurn();
                    }
                });
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('keydown', (e) => {
            if(!isPlaying) return;
            if(e.key === 'ArrowLeft' && currentLane > 0) currentLane--;
            else if(e.key === 'ArrowRight' && currentLane < 2) currentLane++;
            targetLaneX = lanes[currentLane];
        });

        function startGame(level) {
            maxNumber = level;
            questionCount = 0;
            correctAnswers = 0;
            confettis = [];
            smokeParticles.forEach(p => scene.remove(p.mesh));
            smokeParticles = [];
            document.getElementById('progress').innerText = `QUESTION: 0 / 10`;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('end-screen').style.display = 'none';
            isPlaying = true;
            objects.forEach(o => scene.remove(o));
            objects = [];
            nextTurn();
        }

        window.onload = init;
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeConfetti();
        });
    </script>
</body>
</html>


